<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>天気図＋テロップ — 統合(all.html)</title>
  <style>
/* inlined styles.css */
html, body {
  margin: 0;
  padding: 0;
  height: 100vh;
  overflow-x: hidden;
  font-family: 'BIZ UDP Gothic', sans-serif;
}

/* ページ全体の背景（地図領域とテロップを含む） */
html, body {
  background-color: #020418;
}

.ticker-wrapper {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 80px; /* テロップを大きく表示するため高さ拡張 */
  background-color: #020418;
  border-top: 1px solid #888888;
  box-sizing: border-box;
  position: relative;
  color: #fff;
  display: flex;
  align-items: center;
  padding-right: 180px; /* 時計のための余白を確保 */
 }

 /* テロップ左側に垂直な目印の棒を表示 */
 .ticker-wrapper::before {
   content: '';
   position: fixed;
   right: 408px; /* 天気図の左隣 */
   bottom: 80px;
   width: 1px;
   height: calc(100vh - 80px);
   background: #888888;
   z-index: 40;
 }
/* テロップ表示用の内部エリア（時計領域と重ならないように幅を制限） */
.ticker-area {
  position: absolute;
  left: 20px; /* 左側に20pxの余白 */
  right: 10px; /* 時計のすぐ左まで拡張 */
  height: 100%;
  overflow: hidden;
}

.ticker-area .ticker {
  position: absolute;
}

.ticker {
  position: absolute;
  white-space: nowrap;
  font-size: 40px; /* フォントを大きく */
  left: 100%;
  top: 50%;
  transform: translateY(-50%);
  line-height: 1;
  will-change: transform;
}

.ticker img {
  vertical-align: middle;
  height: 44px; /* アイコンを大きく */
  margin: 0 8px 0 8px;
}

.clock {
  background-color: #020418;
  font-size: 63px; /* 時計を大きく */
  color: #fff;
  position: absolute;
  top: 46%;
  transform: translateY(-50%); /* 垂直中央に配置してフォントサイズ変更で下に隙間が出ないようにする */
  right: 14px;
  line-height: 1;
  margin: 0;
  padding: 0;
  user-select: none;
}

.temp {
  margin-left: 12px;
  font-weight: bold;
  font-size: 40px; /* 最高/最低気温を大きく */
  user-select: none;
}

.max-temp {
  color: #ff4444; /* 赤 */
}

.min-temp {
  color: #4466ff; /* 青 */
}

.region-name {
  margin-left: 6px;
}

.slash {
  margin: 0;
  color: #fff;
  user-select: none;
  font-weight: normal;
  font-size: 34px; /* 区切り文字も大きめに */
}

/* 天気図表示領域 */
.container {
  width: 100%;
  height: calc(100vh - 80px); /* テロップの高さに合わせて調整 */
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 10px;
  box-sizing: border-box;
}

#loading {
  color: #cccccc;
  text-align: center;
}

#weatherMap {
  /* 右下に固定表示。テロップ（下部）と被らないように配置 */
  position: fixed;
  /* 右端からの余白（十分なスペースを確保） */
  right: 30px;
  bottom: 96px; /* テロップの上に少し余白を確保（テロップ高さ80 + 16） */
  width: min(40vw, 560px);
  max-width: 360px;
  max-height: calc(100vh - 160px);
  object-fit: contain;
  display: block;
  z-index: 50;
  border-radius: 6px;
  box-shadow: 0 6px 18px rgba(0,0,0,0.5);
}

/* 右上に直接表示する警報ページ用フレーム */
/* 埋め込み警報ウィジェット（警報表示を index 内に統合） */
.warning-embedded {
  position: fixed;
  top: 12px;
  right: 12px;
  left: auto;
  z-index: 110;
  /* 幅はビューポートに応じて可変に。白線（right:408px）を越えないよう最大幅を制限 */
  /* widget の right は 12px 固定なので、最大幅 = 408px - 12px = 396px */
  width: min(40vw, 396px);
  max-width: 396px;
  /* 高さは JS で天気図の上端に合わせて調整する。フォールバックは 60vh */
  max-height: 60vh;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.04);
  box-shadow: 0 6px 14px rgba(0,0,0,0.35);
  overflow: auto;
  padding: 12px;
  box-sizing: border-box;
}

/* ページ上部のNHKニュース見出し（白線の左側に収める） */
.news-top {
  position: fixed;
  top: 19px;
  left: 20px;
  right: calc(408px + 20px);
  z-index: 9999;     /* ★ 常に最前面に */
  color: #fff;
  font-size: 40px;
  font-weight: 600;
  line-height: 1.1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  padding: 6px 10px;
  box-sizing: border-box;
  user-select: none;
  text-align: center;
}



.warning-embedded #warning-card-container {
  display: flex;
  flex-direction: column;
  gap: 10px;
  align-items: center;
  color: #fff;
  margin-top: 10px; /* タイトルより少し下にずらす */
}

/* タイトル（警報見出し） */
.warning-embedded .warning-title {
  text-align: center;
  font-size: var(--warning-title-size, 18px); /* 可変に */
  color: #e6e6e6;
  margin-bottom: 14px;
  font-weight: 700;
  letter-spacing: 0.02em;
}

.warning-embedded .card {
  /* 強調された長方形（元の見た目に近いスタイル） */
  background: #111;
  border: 2px solid #fff;
  border-radius: 10px;
  padding: var(--card-padding, 14px); /* 可変パディング */
  min-height: var(--card-min-height, 58px); /* 可変高さ */
  width: 100%;
  box-sizing: border-box;
  display: flex;
  gap: 10px;
  align-items: center;
  box-shadow: 0 4px 12px rgba(0,0,0,0.6);
}

.warning-embedded .region { font-weight: bold; color: #fff; }

.warning-embedded .warning {
  padding: 2px 6px;
  border-radius: 5px;
  color: #000;
  text-align: center;
  white-space: nowrap;
}
.warning-embedded .警報 { background-color: red; }
.warning-embedded .注意報 { background-color: yellow; }
/* 廃止 */
/* .warning-embedded .解除 { background-color: gray; } */

/* スクロールバーを非表示（スクロール自体は可能） */
.warning-embedded {
  -ms-overflow-style: none; /* IE/Edge */
  scrollbar-width: none;    /* Firefox */
}
.warning-embedded::-webkit-scrollbar {
  display: none; /* Chrome, Safari, Opera */
  width: 0;
  height: 0;
}

/* iframe 内を埋めるため、内部の body は warning.html 側で管理してください */

/* サイト全体のスクロールバーを非表示にする（スクロールは維持） */
html, body {
  -ms-overflow-style: none; /* IE/Edge */
  scrollbar-width: none;    /* Firefox */
}
html::-webkit-scrollbar, body::-webkit-scrollbar {
  display: none; /* Chrome, Safari, Opera */
  width: 0;
  height: 0;
}
#map {
  position: fixed;
  left: 0px;
  right: 408px;
  top: 0;
  bottom: 80px;
  z-index: 30;
  background: #1d1d1d;
}
/* 左端パネル（地図の上に重ねる） */
/* 上のタイトル長方形 */
#map-left-panel-title {
  position: absolute;
  top: 15px;
  left: 15px;
  width: 400px;
  height: 65px; /* タイトル枠の高さ */
  background: rgba(0, 0, 0, 0.55); /* 下より濃く */
  color: white;
  font-size: 35px;
  font-weight: bold;
  text-align: center;
  line-height: 60px; /* テキストを中央に */
  z-index: 2000;
  pointer-events: none;
  border-radius: 4px;
}

/* 下の半透明パネル */
#map-left-panel {
  position: absolute;
  top: 90px;   /* タイトル（60px）＋余白30px */
  left: 15px;
  width: 400px;
  bottom: 95px;
  background: rgba(0, 0, 0, 0.35);
  z-index: 1999;
  pointer-events: none;
  border-radius: 4px;
}
#eq-info {
  padding: 20px;
  color: white;
  font-family: "Segoe UI", sans-serif;
  pointer-events: auto;
}

/* 最大震度の小さいアイコン */
.eq-maxscale-icon {
  width: 38px;
  height: 38px;
  vertical-align: middle;
}



/* 最大震度テキスト */
.eq-maxscale {
  text-align: center;
  font-size: 38px;
  font-weight: bold;
  color: white; /* ← 白文字 */
}

/* 時刻 */
.eq-time {
    text-align: center;
font-weight: bold;
  font-size: 30px;
}

/* 震源地 */
.eq-hypo {
  font-weight: bold;
  font-size: 30px;
}

/* 下の通常テキスト */
.eq-item {
  font-weight: bold;
  font-size: 30px;
}
.eq-tsunami-warning {
  font-weight: bold;
  font-size: 30px;
}
  </style>
    <!-- === Leaflet の CSS/JS を追加（必要最小限） === -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
          integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <script src="./source/JMAPoints.js"></script>
  <script src="source/SmoothWheelZoom.js"></script>
</head>
<body>
<div id="map-left-panel-title">地震情報</div>
<div id="map-left-panel">
    <div id="eq-info">読み込み中...</div>
</div>

  <div class="container">
    <img id="weatherMap" src="" alt="気象庁天気図" style="display:none;" />
    <p id="loading">天気図を読み込み中...</p>
  </div>
  <!-- === ここに Leaflet 地図を追加（あなたの元コードに対する最小変更） === -->
<!-- 地図全体エリア -->
  <div id="leaflet-map"
       style="
         position: fixed;
         left: 000px;
         right: 408px;
         top: 0;
         bottom: 80px;
         z-index: 30;
         background: #1d1d1d;
       "
       aria-hidden="false"
       role="region"
       aria-label="日本地図">
  </div>
  <div id="map"></div>

  <!-- 右上に警報ウィジェットを直接埋め込み -->
  <div id="warning-widget" class="warning-embedded" aria-label="警報・注意報ウィジェット">
    <div class="warning-title">発表されている警報/注意報</div>
    <div id="warning-card-container">読み込み中...</div>
  </div>

  <div class="ticker-wrapper">
    <div class="ticker-area">
      <div class="ticker" id="ticker"></div>
    </div>
    <div class="clock" id="clock"></div>
  </div>
  <script>
// inlined script.js
// script.js — 統合版（WARNINGSIZE でカード数を制御、UIは生成しない）

const ticker = document.getElementById("ticker");
const wrapper = document.querySelector(".ticker-wrapper");
const tickerArea = document.querySelector('.ticker-area');
const clock = document.getElementById("clock");

// 設定: JS側で枚数だけ指定したい場合はここを編集してください
// WARNINGSIZE を 0 にすると画面解像度に合わせた自動算出を有効にします
const WARNINGSIZE = 0; // 0 = 自動（解像度ベース）。正の整数を入れると固定枚数になります。
const WARNING_WIDGET_ENABLED = true; // false にするとウィジェットを完全に無効化します

// 時計領域とテロップの余白調整
const CLOCK_LEFT_GAP = 12;
function updateTickerAreaRight() {
  if (!tickerArea || !clock) return;
  const cs = window.getComputedStyle(clock);
  const clockRight = parseInt(cs.right) || 8;
  const clockWidth = clock.offsetWidth || 0;
  const rightPx = clockWidth + clockRight + CLOCK_LEFT_GAP;
  tickerArea.style.right = rightPx + 'px';
}
window.addEventListener('resize', updateTickerAreaRight);
window.addEventListener('load', updateTickerAreaRight);

// 天気図要素
const weatherMapImg = document.getElementById('weatherMap');
const loadingText = document.getElementById('loading');

let weatherHTMLs = [];
let quakeMessage = '';
let lastQuakeSignature = '';
// NHK 上部見出し用
let topNewsTitles = [];
let topNewsIndex = 0;
let topNewsIntervalId = null;
let topNewsQueue = [];
let prevTopNewsSnapshot = '';
// 表示時間(ms): ニュース速報の表示時間と見出し1件表示時間
const TOP_NEWS_ALERT_MS = 1000; // "ニュース速報" 表示時間（ミリ秒）
const TOP_NEWS_ITEM_MS = 5000; // 各見出しの表示時間（ミリ秒）
let topNewsAudio = null;
// API 全体の内容を保持する変数。更新があれば表示トリガーに使う。
let API = '';
let combinedItems = [];
let currentIndex = 0;
let animationId = null;
let warningShowIntervalId = null;
// 更新時にすぐに切り替えず、現在の一巡が終わるまで保留するための変数
let pendingCombinedItems = null;
// 時計
function updateClock() {
  const now = new Date();
  const hh = String(now.getHours()).padStart(2, "0");
  const mm = String(now.getMinutes()).padStart(2, "0");
  const ss = String(now.getSeconds()).padStart(2, "0");
  if (clock) clock.textContent = `${hh}:${mm}:${ss}`;
}
setInterval(updateClock, 1000);
updateClock();
var map = L.map('map', { preferCanvas: true, smoothWheelZoom: true,scrollWheelZoom: false, smoothSensitivity: 1.5,}).setView([36.575, 137.984], 6);
L.control.scale({ maxWidth: 150, position: 'bottomright', imperial: false }).addTo(map);
map.zoomControl.setPosition('topright');

var JMAPointsJson;

//地図に表示させる上下の順番
map.createPane("pane_map1").style.zIndex = 1; //地図（背景）
map.createPane("pane_map2").style.zIndex = 2; //地図（市町村）
map.createPane("pane_map3").style.zIndex = 3; //地図（細分）
map.createPane("pane_map_filled").style.zIndex = 5; //塗りつぶし
map.createPane("shindo10").style.zIndex = 10;
map.createPane("shindo20").style.zIndex = 20;
map.createPane("shindo30").style.zIndex = 30;
map.createPane("shindo40").style.zIndex = 40;
map.createPane("shindo45").style.zIndex = 45;
map.createPane("shindo46").style.zIndex = 46;
map.createPane("shindo50").style.zIndex = 50;
map.createPane("shindo55").style.zIndex = 55;
map.createPane("shindo60").style.zIndex = 60;
map.createPane("shindo70").style.zIndex = 70;
map.createPane("shingen").style.zIndex = 100; //震源
map.createPane("tsunami_map").style.zIndex = 110; //津波

// ---- あなたのスタイル ----
var PolygonLayer_Style_nerv = {
    "color": "#ffffff",
    "weight": 1.5,
    "opacity": 1,
    "fillColor": "#3a3a3a",
    "fillOpacity": 1
};
map.attributionControl.addAttribution(
    "<a href='https://github.com/mutsuyuki/Leaflet.SmoothWheelZoom' target='_blank'>SmoothWheelZoom</a>"
);
map.attributionControl.addAttribution('地図データ &copy; <a href="https://www.jma.go.jp/jma/index.html" target="_blank">気象庁</a>');
// ---- 日本の都道府県 GeoJSON
var japan_data;
fetch("source/saibun.geojson")
  .then(response => response.json())
  .then(data => {
      japan_data = data;
      L.geoJson(data, {
        pane: "pane_map3",
          style: PolygonLayer_Style_nerv
      }).addTo(map);
  })
  .catch(err => console.error(err));
//気象庁観測点データ読み込み
fetch("source/JMAstations.json")
  .then(res => res.json())
  .then(data => {
      JMAPointsJson = data;
      fetchQuakeData();
  });

var shindo_icon;
var shindo_layer = L.layerGroup();
var shindo_filled_layer = L.layerGroup();
var filled_list = {};

//地震情報
function fetchQuakeData() {
  var url;
  
    url = "https://api.p2pquake.net/v2/history?codes=551&limit=1";
    $.getJSON(url, function (data) {
    var [time, name, shindo, magnitude, depth] = [
        data["0"]["earthquake"]["time"],
        data["0"]["earthquake"]["hypocenter"]["name"],
        data["0"]["earthquake"]["maxScale"],
        data["0"]["earthquake"]["hypocenter"]["magnitude"],
        data["0"]["earthquake"]["hypocenter"]["depth"]
    ]
    console.log(time+"ごろ、"+name+"で最大震度"+shindo/10+"の地震が発生しました。マグニチュードは"+magnitude+"、深さ"+depth+"kmと推定されています。");

    var shingenLatLng = new L.LatLng(data[0]["earthquake"]["hypocenter"]["latitude"], data[0]["earthquake"]["hypocenter"]["longitude"]);
    var shingenIconImage = L.icon({
        iconUrl: 'source/Shingen.png',
        iconSize: [40, 40],
        iconAnchor: [20, 20],
        popupAnchor: [0, -40]
    });
    if (shingenIcon && shindo_layer && shindo_filled_layer) {
        map.removeLayer(shingenIcon);
        map.removeLayer(shindo_layer);
        map.removeLayer(shindo_filled_layer);
        shingenIcon = "";
        shindo_layer = L.layerGroup();
        shindo_filled_layer = L.layerGroup();
        filled_list = {};
        shindo_icon = "";
    }
// 震度アイコン画像 URL を作る
let shindoIconUrl = `source/Shindo/jqk_int${shindo}.png`;

// HTML作成
var infoHTML = `
  <div class="eq-maxscale">
    最大震度 <img src="${shindoIconUrl}" class="eq-maxscale-icon"></div>
  <div class="eq-time">${formatJSTDate(time)}</div>
  <div class="eq-hypo">震源地：${name}</div>
  <div class="eq-item">地震の規模：M${hantei_Magnitude(magnitude)}</div>
  <div class="eq-item">震源の深さ：${hantei_Depth(depth)}</div>
  <div class="eq-tsunami-warning">津波の心配：${hantei_tsunamiText(data[0]["earthquake"]["domesticTsunami"])}</div>
`;


document.getElementById("eq-info").innerHTML = infoHTML;


    if (data[0]["issue"]["type"] != "ScalePrompt") { //各地の震度に関する情報


    // 新しく震源アイコンを追加
    shingenIconMarker = L.marker(shingenLatLng, {
        icon: shingenIconImage
    }).addTo(map);
        data[0]["points"].forEach(element => {
        var result = JMAPointsJson.findIndex(st => element["addr"].includes(st.name));
        if (result != -1) {
            var ImgUrl = "";
            var PointShindo = "";
            var icon_theme = "Shindo/jqk";
            if (element["scale"] == 10) {
                ImgUrl = "source/"+icon_theme+"_int10.png";
                PointShindo = "震度1";
            } else if (element["scale"] == 20) {
                ImgUrl = "source/"+icon_theme+"_int20.png";
                PointShindo = "震度2";
            } else if (element["scale"] == 30) {
                ImgUrl = "source/"+icon_theme+"_int30.png";
                PointShindo = "震度3";
            } else if (element["scale"] == 40) {
                ImgUrl = "source/"+icon_theme+"_int40.png";
                PointShindo = "震度4";
            } else if (element["scale"] == 45) {
                ImgUrl = "source/"+icon_theme+"_int50.png";
                PointShindo = "震度5弱";
            } else if (element["scale"] == 46) {
                ImgUrl = "source/"+icon_theme+"_int_.png";
                PointShindo = "震度5弱以上と推定";
            } else if (element["scale"] == 50) {
                ImgUrl = "source/"+icon_theme+"_int55.png";
                PointShindo = "震度5強";
            } else if (element["scale"] == 55) {
                ImgUrl = "source/"+icon_theme+"_int60.png";
                PointShindo = "震度6弱";
            } else if (element["scale"] == 60) {
                ImgUrl = "source/"+icon_theme+"_int65.png";
                PointShindo = "震度6強";
            } else if (element["scale"] == 70) {
                ImgUrl = "source/"+icon_theme+"_int70.png";
                PointShindo = "震度7";
            } else {
                ImgUrl = "source/"+icon_theme+"_int_.png";
                PointShindo = "震度不明";
            }
            if (element["isArea"] == false) { //観測点
                let shindo_latlng = new L.LatLng(JMAPointsJson[result]["lat"], JMAPointsJson[result]["lon"]);
                let shindoIcon = L.icon({
                    iconUrl: ImgUrl,
                    iconSize: [20, 20],
                    popupAnchor: [0, -40]
                });
                let shindoIcon_big = L.icon({
                    iconUrl: ImgUrl,
                    iconSize: [34, 34],
                    popupAnchor: [0, -40]
                });
                shindo_icon = L.marker(shindo_latlng, { 
                 icon: shindoIcon,
                  pane: "shindo" + element["scale"]
                });

                shindo_icon.bindPopup('<ruby>'+element["addr"] + '<rt style="font-size: 0.7em;">' + JMAPointsJson[result]["furigana"] + '</rt></ruby>　'+ PointShindo,{closeButton: false, zIndexOffset: 10000,autoPan: false,});
                shindo_icon.on('mouseover', function (e) {
                    this.openPopup();
                });
                shindo_icon.on('mouseout', function (e) {
                    this.closePopup();
                });
                shindo_layer.addLayer(shindo_icon);
                //塗りつぶしの設定をする
                //AreaNameToCode()は下を参照。大阪府北部を520等に変換
                //filled_listは連想配列で{520: 10, 120: 20}など、エリアコード: 震度の大きさ
                var areaCode = AreaNameToCode(JMAPointsJson[result]["area"]["name"]);
                //filled_listにエリアコードがなかったり、さらに大きな震度になっていたら更新
                if ((!filled_list[areaCode]) || filled_list[areaCode] < element["scale"]) {
                    filled_list[areaCode] = element["scale"];
                }
                
            }
            
            //for(... in ...)もforEachと同等。keyに連想配列の名前が入る
            for (key in filled_list){ 
                var PointColor;
                if (filled_list[key] == 10) {
                  PointColor = "RGB(72, 85, 85)";
                } else if (filled_list[key] == 20) {
                  PointColor = "RGB(0, 75, 195)";
                } else if (filled_list[key] == 30) {
                  PointColor = "RGB(15, 145, 65)";
                } else if (filled_list[key] == 40) {
                  PointColor = "RGB(220, 189, 58)";
                } else if (filled_list[key] == 45) {
                  PointColor = "RGB(220, 135, 0)";
                } else if (filled_list[key] == 46) {
                  PointColor = "RGB(220, 135, 0)";
                } else if (filled_list[key] == 50) {
                  PointColor = "RGB(204, 77, 0)";
                } else if (filled_list[key] == 55) {
                  PointColor = "RGB(195, 0, 0)";
                } else if (filled_list[key] == 60) {
                  PointColor = "RGB(125, 0, 0)";
                } else if (filled_list[key] == 70) {
                  PointColor = "RGB(58, 0, 109)";
                }
                //引数"key"はエリアコード、"PointColor"は塗りつぶし色のHEX値
                FillPolygon(key, PointColor);
            }
            
        }
        });
    }else{
    var icon_theme = "Shindo/jqk";
    var latlon;
    var latList = [];
    var lonList = [];


    data[0]["points"].forEach(element => {
        var ImgUrl = "";
        var PointShindo = "";
        var PointColor;
         if (element["scale"] == 10) {
            eval('PointColor = "RGB(72, 85, 85)"');
            ImgUrl = "source/"+icon_theme+"_int1.png";
            PointShindo = "震度1";
        } else if (element["scale"] == 20) {
            eval('PointColor = "RGB(0, 75, 195)"');
            ImgUrl = "source/"+icon_theme+"_int2.png";
            PointShindo = "震度2";
        } else if (element["scale"] == 30) {
            eval('PointColor = "RGB(15, 145, 65)"');
            ImgUrl = "source/"+icon_theme+"_int3.png";
            PointShindo = "震度3";
        } else if (element["scale"] == 40) {
            eval('PointColor = "RGB(220, 189, 58)"');
            ImgUrl = "source/"+icon_theme+"_int4.png";
            PointShindo = "震度4";
        } else if (element["scale"] == 45) {
            eval('PointColor = "RGB(220, 135, 0)"');
            ImgUrl = "source/"+icon_theme+"_int50.png";
            PointShindo = "震度5弱";
        } else if (element["scale"] == 46) {
            eval('PointColor = "RGB(220, 135, 0)"');
            ImgUrl = "source/"+icon_theme+"_int_.png";
            PointShindo = "震度5弱以上と推定";
        } else if (element["scale"] == 50) {
            eval('PointColor = "RGB(204, 77, 0)"');
            ImgUrl = "source/"+icon_theme+"_int55.png";
            PointShindo = "震度5強";
        } else if (element["scale"] == 55) {
            eval('PointColor = "RGB(195, 0, 0)"');
            ImgUrl = "source/"+icon_theme+"_int60.png";
            PointShindo = "震度6弱";
        } else if (element["scale"] == 60) {
            eval('PointColor = "RGB(125, 0, 0)"');
            ImgUrl = "source/"+icon_theme+"_int65.png";
            PointShindo = "震度6強";
        } else if (element["scale"] == 70) {
            eval('PointColor = "RGB(58, 0, 109)"');
            ImgUrl = "source/"+icon_theme+"_int7.png";
            PointShindo = "震度7";
        } else {
            eval('PointColor = "RGB(57, 59, 59)"');
            ImgUrl = "source/"+icon_theme+"_int_.png";
            PointShindo = "震度不明";
        }
            var area_Code = AreaNameToCode(element["addr"]);
            latlon = FillPolygon(area_Code, PointColor);
            latList.push(Number(latlon["lat"]));
            lonList.push(Number(latlon["lng"]));
            let shindoIcon = L.icon({
                iconUrl: ImgUrl,
                iconSize: [30, 30],
                popupAnchor: [0, -50]
            });
            var shindo_icon = L.marker(latlon, { icon: shindoIcon,pane: eval('\"shindo'+element["scale"]+'\"') });
            shindo_icon.bindPopup('<ruby>'+element["addr"] + '<rt style="font-size: 0.7em;">' + AreaNameToKana(element["addr"]) + '</rt></ruby>　'+ PointShindo,{closeButton: false, zIndexOffset: 10000,autoPan: false,});
            shindo_icon.on('mouseover', function (e) {
                this.openPopup();
            });
            shindo_icon.on('mouseout', function (e) {
                this.closePopup();
            });
            shindo_layer.addLayer(shindo_icon);
            // console.log(element["addr"] + " " + PointShindo + " OK");
        });
        const aryMax = function (a, b) {return Math.max(a, b);}
        const aryMin = function (a, b) {return Math.min(a, b);}
        var latMax = latList.reduce(aryMax);
        var latMin = latList.reduce(aryMin);
        var lonMax = lonList.reduce(aryMax);
        var lonMin = lonList.reduce(aryMin);
        //通常時の位置初期化の位置
        shingenLatLng = new L.LatLng(Number((latMax+latMin)/2), Number((lonMax+lonMin)/2));
        latList = [];
        lonList = [];
    }
    map.addLayer(shindo_layer);
    map.addLayer(shindo_filled_layer);
   var shingenIcon = L.marker(shingenLatLng, {icon: shingenIconImage }).addTo(map);
    map.flyTo(shingenLatLng, 7.5, { duration: 0.5 })

});
function formatJSTDate(dateStr) {
    const date = new Date(dateStr);

    // 月は 0 始まりなので +1
    const month = date.getMonth() + 1;
    const day   = date.getDate();
    const hour  = date.getHours();
    const min   = date.getMinutes().toString().padStart(2, "0");

    return `${month}月${day}日 ${hour}時${min}分ごろ`;
}

}
function AreaNameToCode(Name) {
    var array_Num = AreaName.indexOf(Name);
    return AreaCode[array_Num];
}
function AreaCodeToName(code) {
    var array_Num = AreaCode.indexOf(code);
    return AreaName[array_Num];
}
function AreaNameToKana(Name) {
    var array_Num = AreaName.indexOf(Name);
    return AreaKana[array_Num];
}
function FillPolygon(area_Code, PointColor) {
    var array_Num = AreaCode.indexOf(area_Code);
    if (array_Num != -1) {
        var style;
        style = {
            "color": "#ffffff",
            "weight": 1.2,
            "opacity": 1,
            "fillColor": PointColor,
            "fillOpacity": 1,
        }
        data_japan = japan_data["features"][array_Num];
        var Filled_Layer = L.geoJSON(data_japan, {
            style: style,
            pane: "pane_map_filled",
            onEachFeature: function (feature, layer) {
                if (feature.properties && feature.properties.popupContent) {
                    layer.bindPopup(feature.properties.popupContent);
                }
                layer.myTag = "Filled"
            },
        });
        shindo_filled_layer.addLayer(Filled_Layer);
        map.addLayer(Filled_Layer);
        var geodata = data_japan["geometry"]["coordinates"][0];
        let latlon;
        map.eachLayer(function (layer) {
            if (layer.myTag && layer.myTag === "Filled") {
                latlon = layer.getCenter();
            }
        });
        map.removeLayer(Filled_Layer);
        return latlon;
    }
}
function hantei_maxIntText(param) {
    let kaerichi = param == 10 ? "1" : param == 20 ? "2" : param == 30 ? "3" : param == 40 ? "4" :
    param == 45 ? "5弱" : param == 46 ? "5弱" : param == 50 ? "5強" : param == 55 ? "6弱" :
    param == 60 ? "6強" : param == 70 ? "7" : "不明";
    return kaerichi;
}
function hantei_Magnitude(param) {
    let kaerichi = param != -1 ? param.toFixed(1) : 'ー.ー';
    return kaerichi;
}
function hantei_Name(param) {
    let kaerichi = param != "" ? param : '情報なし';
    return kaerichi;
}
function hantei_Depth(param) {
    let kaerichi = param != -1 ? "約"+param+"km" : '不明';
    return kaerichi;
}
function hantei_tsunamiText(param) {
    let kaerichi = param == "None" ? "なし" :
    param == "Unknown" ? "不明" :
    param == "Checking" ? "調査中" :
    param == "NonEffective" ? "若干の海面変動" :
    param == "Watch" ? "津波注意報" :
    param == "Warning" ? "津波警報" : "情報なし";
    return kaerichi;
}

// 天気図読み込み
async function loadWeatherMap() {
  if (!weatherMapImg || !loadingText) return;
  try {
    const res = await fetch('https://www.jma.go.jp/bosai/weather_map/data/list.json');
    const data = await res.json();
    if (data.near && data.near.now && data.near.now.length > 0) {
      const firstCode = data.near.now[21];
      const imageUrl = `https://www.jma.go.jp/bosai/weather_map/data/png/${firstCode}`;
      weatherMapImg.onload = function() {
        weatherMapImg.style.display = 'block';
        loadingText.style.display = 'none';
        updateWarningWidgetHeight();
        console.log('天気図を読み込みました:', imageUrl);
      };
      weatherMapImg.onerror = function(e) {
        console.error('天気図画像読み込みエラー', e);
        loadingText.textContent = '天気図の読み込みに失敗しました';
        updateWarningWidgetHeight();
      };
      weatherMapImg.src = imageUrl;
    } else {
      loadingText.textContent = '天気図データが見つかりませんでした';
    }
  } catch (e) {
    console.error('天気図取得失敗:', e);
    loadingText.textContent = '天気図の読み込みに失敗しました';
  }
}

// ウィジェット高さを天気図上端ギリギリまで合わせる
function updateWarningWidgetHeight() {
  if (!WARNING_WIDGET_ENABLED) return;
  const widget = document.getElementById('warning-widget');
  const map = document.getElementById('weatherMap');
  if (!widget) return;
  const topOffset = 12;
  const gap = 8;
  if (map && map.style.display !== 'none') {
    const rect = map.getBoundingClientRect();
    let maxH = Math.floor(rect.top - gap - topOffset);
    if (maxH < 80) maxH = 80;
    widget.style.maxHeight = maxH + 'px';
    widget.style.overflow = 'auto';
  } else {
    const maxH = Math.max(120, Math.floor(window.innerHeight - topOffset - 24));
    widget.style.maxHeight = Math.min(maxH, Math.floor(window.innerHeight * 0.8)) + 'px';
    widget.style.overflow = 'auto';
  }
}
window.addEventListener('resize', updateWarningWidgetHeight);
window.addEventListener('load', updateWarningWidgetHeight);

// 天気情報取得
async function fetchWeather() {
  try {
    const res = await fetch("https://weathernews.jp/forecast/xml/all.xml");
    const xmlText = await res.text();
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlText, "text/xml");
    const points = Array.from(xmlDoc.getElementsByTagName("point"));

    const uniquePoints = {};
    points.forEach(point => {
      const id = point.getAttribute("id");
      if (!uniquePoints[id]) {
        const name = point.getAttribute("name");
        const weatherRaw = point.getElementsByTagName("weather")[0]?.textContent || "";
        const firstWeatherValue = weatherRaw.split(",")[0];
        const iconUrl = `https://weathernews.jp/s/topics/img/wxicon/${firstWeatherValue}.png`;
        const maxtempRaw = point.getElementsByTagName("maxtemp")[0]?.textContent || "";
        const mintempRaw = point.getElementsByTagName("mintemp")[0]?.textContent || "";
        const maxtemp = maxtempRaw.match(/\d+/)?.[0] || "-";
        const mintemp = mintempRaw.match(/\d+/)?.[0] || "-";
        const html = `\n        <img src="${iconUrl}" alt="weather icon">\n        <span class="region-name">${name}</span>\n        <span class="temp max-temp">${maxtemp}℃</span><span class="slash">  /</span><span class="temp min-temp">${mintemp}℃</span>\n      `;
        uniquePoints[id] = html;
      }
    });
    weatherHTMLs = Object.values(uniquePoints);
  } catch (e) {
    console.error("天気取得失敗:", e);
    weatherHTMLs = [`<span>天気情報を取得できませんでした。</span>`];
  }
}

// ニュース機能は削除されました（RSS取得とテキスト配列を使用しません）。

// 地震情報取得（p2pquake 履歴 API）
async function fetchQuake() {
  try {
    const res = await fetch('https://api.p2pquake.net/v2/history?codes=551&limit=1');
    const json = await res.json();
    if (!Array.isArray(json) || json.length === 0) {
      quakeMessage = '';
      return;
    }
    const ev = json[0];
    // 柔軟にフィールドを取得
    const depth = ev.depth ?? ev.hypocenter?.depth ?? ev.jma?.depth ?? ev['hypocenter.depth'] ?? '';
    const magnitude = ev.magnitude ?? ev.hypocenter?.magnitude ?? ev['magnitude'] ?? '';
    const name = ev.name ?? ev.hypocenter?.name ?? ev.jma?.name ?? ev['place'] ?? '';
    const maxScale = ev.maxScale ?? ev.maxInt ?? ev.jma?.maxScale ?? ev['maxscale'] ?? '';
    const timeRaw = ev.time ?? ev['time'] ?? ev['origin_time'] ?? '';
    // time を HH:MM 形式だけ取り出す
    let hhmm = '';
    if (timeRaw) {
      const d = new Date(timeRaw);
      if (!isNaN(d.getTime())) {
        const hh = String(d.getHours()).padStart(2, '0');
        const mm = String(d.getMinutes()).padStart(2, '0');
        hhmm = `${hh}:${mm}`;
      }
    }

    // 必要な情報が揃っていればメッセージを作成
    let newMessage = '';
    if (hhmm && maxScale !== '' && name && depth !== '' && magnitude !== '') {
      newMessage = `先ほど${hhmm}頃、最大震度${maxScale}を観測する地震がありました。震源地は${name}で震源の深さは約${depth}km、地震の規模を示すマグニチュードはM${magnitude}と推定されています。`;
    }

    // 変化検知: API 全体の内容が変わったら更新
    try {
      const apiText = JSON.stringify(json);
      if (apiText && apiText !== API) {
        API = apiText;
        lastQuakeSignature = [hhmm, maxScale, name, depth, magnitude].join('|');
        quakeMessage = newMessage;
        return true; // updated
      }
    } catch (e) {
      // JSON.stringify が失敗したらフォールバックで署名比較
      const signature = [hhmm, maxScale, name, depth, magnitude].join('|');
      if (signature && signature !== lastQuakeSignature) {
        lastQuakeSignature = signature;
        quakeMessage = newMessage;
        return true;
      }
    }
    // 変化がなければ何もしない
    return false;
  } catch (e) {
    console.error('地震情報取得失敗:', e);
    return false;
  }
}

// 天気HTML連結
function getCombinedWeatherHTML() {
  return weatherHTMLs.join('　');
}
// ビルド専用: 合成アイテム配列を返す（ただちに適用しない）
function buildCombinedItems() {
  const combinedWeather = getCombinedWeatherHTML();
  if (quakeMessage && quakeMessage.length > 0) {
    return [quakeMessage, combinedWeather];
  }
  return [combinedWeather];
}

// テロップ
const speedWeather = 200;
const speedNews = 100;
function startTicker() {
  if (!ticker) return;
  if (combinedItems.length === 0) return;
  if (animationId) cancelAnimationFrame(animationId);
  updateTickerAreaRight();
  ticker.innerHTML = combinedItems[currentIndex];
  const areaWidth = (tickerArea && tickerArea.offsetWidth) ? tickerArea.offsetWidth : wrapper.offsetWidth;
  ticker.style.left = areaWidth + "px";
  let posX = areaWidth;
  const fps = 60;
  function animate() {
    const speed = (currentIndex === 0) ? speedWeather : speedNews;
    const step = speed / fps;
    posX -= step;
    ticker.style.left = posX + "px";
    if (posX + ticker.offsetWidth < 0) {
      currentIndex = (currentIndex + 1) % combinedItems.length;
      // 一巡して先頭に戻ったタイミングで保留中の更新があれば適用する
      if (currentIndex === 0 && pendingCombinedItems && Array.isArray(pendingCombinedItems)) {
        combinedItems = pendingCombinedItems;
        pendingCombinedItems = null;
        currentIndex = 0;
        // 新しい先頭を描画
        ticker.innerHTML = combinedItems[currentIndex];
      } else {
        if (currentIndex === 0) ticker.innerHTML = combinedItems[currentIndex];
        else ticker.textContent = combinedItems[currentIndex];
      }
      posX = (tickerArea && tickerArea.offsetWidth) ? tickerArea.offsetWidth : wrapper.offsetWidth;
    }
    animationId = requestAnimationFrame(animate);
  }
  animationId = requestAnimationFrame(animate);
}

// 地震メッセージを即時に先頭で流す（強制表示）
function showQuakeNow() {
  if (!quakeMessage) return;
  // 即時割り込みは行わず、次の一巡が終わった時点で適用する（現在の表示を邪魔しない）
  const newItems = buildCombinedItems();
  if (animationId) {
    pendingCombinedItems = newItems;
  } else {
    combinedItems = newItems;
    currentIndex = 0;
    startTicker();
  }
}

// 全更新
async function updateAll() {
  await loadWeatherMap();
  await fetchWeather();
  const quakeChanged = await fetchQuake();
  if (WARNING_WIDGET_ENABLED && typeof loadAllRegions === 'function') {
    try { await loadAllRegions(); } catch(e){ console.error('loadAllRegions エラー', e); }
    try { updateWarningWidgetHeight(); } catch(e) { /* ignore */ }
  }
  const newItems = buildCombinedItems();
  if (animationId) {
    // 表示中なら一巡が終わるまで適用を保留する
    pendingCombinedItems = newItems;
  } else {
    // 未表示なら即時適用
    combinedItems = newItems;
    currentIndex = 0;
    startTicker();
  }
  // 上部ニュースも更新
  try { await fetchTopNews(); } catch(e) { console.error('top news fetch error', e); }
}

updateAll();
async function earthquakeupdateAll() {
  await fetchQuakeData();
}
earthquakeupdateAll();
setInterval(earthquakeupdateAll, 10000);
setInterval(updateAll, 5 * 60 * 1000);

// 地震APIのポーリング: 30秒ごとに差分をチェックし、更新があればテロップを即時表示する
let quakePollIntervalId = null;
async function startQuakePolling() {
  // 初回取得（既に updateAll で1回取得済みのことが多いが確実に）
  try {
    const changed = await fetchQuake();
    if (changed) {
      // 新着があれば一巡後に適用する形で保留
      const newItems = buildCombinedItems();
      if (animationId) pendingCombinedItems = newItems;
      else { combinedItems = newItems; currentIndex = 0; startTicker(); }
    }
  } catch (e) { /* ignore */ }

  if (quakePollIntervalId) clearInterval(quakePollIntervalId);
  quakePollIntervalId = setInterval(async () => {
    try {
      const changed = await fetchQuake();
      if (changed) {
        const newItems = buildCombinedItems();
        if (animationId) pendingCombinedItems = newItems;
        else { combinedItems = newItems; currentIndex = 0; startTicker(); }
      }
    } catch (e) { console.error('quake poll error', e); }
  }, 30 * 1000);
}

startQuakePolling();

// -------------------------
// 警報ウィジェット: DOM を JS 側で生成（HTML側に直接要素は不要）
// -------------------------
function ensureWarningWidgetExists() {
  if (document.getElementById('warning-widget')) return;
  const widget = document.createElement('div');
  widget.id = 'warning-widget';
  widget.className = 'warning-embedded';
  widget.setAttribute('aria-label', '警報・注意報ウィジェット');
  const title = document.createElement('div');
  title.className = 'warning-title';
  title.textContent = '発表されている気象警報/注意報';
  const container = document.createElement('div');
  container.id = 'warning-card-container';
  container.textContent = '読み込み中...';
  widget.appendChild(title);
  widget.appendChild(container);
  const tickerWrapper = document.querySelector('.ticker-wrapper');
  if (tickerWrapper && tickerWrapper.parentNode) tickerWrapper.parentNode.insertBefore(widget, tickerWrapper);
  else document.body.appendChild(widget);
}

// データ取得と表示
async function loadAllRegions() {
  if (!WARNING_WIDGET_ENABLED) return;
  console.log('[warning] loadAllRegions: start');
  ensureWarningWidgetExists();
  const container = document.getElementById("warning-card-container");
  if (!container) return;
  container.innerHTML = "";
  try {
    const res = await fetch('https://www.data.jma.go.jp/developer/xml/feed/extra.xml');
    const text = await res.text();
    const parser = new DOMParser();
    const xml = parser.parseFromString(text, "application/xml");
    const entries = xml.getElementsByTagNameNS("http://www.w3.org/2005/Atom", "entry");
    console.log('[warning] loadAllRegions: extra.xml entries=', entries.length);
    let allCards = [];
    for (let i = 0; i < entries.length; i++) {
      const linkEl = entries[i].getElementsByTagNameNS("http://www.w3.org/2005/Atom", "link")[0];
      if (!linkEl) continue;
      const href = linkEl.getAttribute("href");
      if (!href) continue;
      try {
        const regionRes = await fetch(href);
        const regionText = await regionRes.text();
        const regionXml = parser.parseFromString(regionText, "application/xml");
        const nsBody = "http://xml.kishou.go.jp/jmaxml1/body/meteorology1/";
        const warnings = regionXml.getElementsByTagNameNS(nsBody, "Warning");
        for (let w = 0; w < warnings.length; w++) {
          const items = warnings[w].getElementsByTagNameNS(nsBody, "Item");
          for (let j = 0; j < items.length; j++) {
            const areaEl = items[j].getElementsByTagNameNS(nsBody, "Area")[0] || items[j].getElementsByTagName("Area")[0];
            const kindEl = items[j].getElementsByTagNameNS(nsBody, "Kind")[0] || items[j].getElementsByTagName("Kind")[0];
            if (!areaEl || !kindEl) continue;
            const regionName = areaEl.getElementsByTagName("Name")[0]?.textContent || "不明地域";
            const warningName = kindEl.getElementsByTagName("Name")[0]?.textContent || "";
            const status = kindEl.getElementsByTagName("Status")[0]?.textContent || "";
            // 解除（解除情報）は表示しない
            if (status && status.includes('解除')) continue;
            if (!warningName || status === "発表警報・注意報はなし") continue;
            const card = document.createElement("div");
            card.className = "card";
            const regionDiv = document.createElement("div");
            regionDiv.className = "region";
            regionDiv.textContent = regionName;
            const warningDiv = document.createElement("div");
            warningDiv.className = "warning";
            if(status.includes("解除")) warningDiv.classList.add("解除");
            else if(warningName.includes("警報")) warningDiv.classList.add("警報");
            else warningDiv.classList.add("注意報");
            warningDiv.textContent = `${warningName} ${status}`.trim();
            card.appendChild(regionDiv);
            card.appendChild(warningDiv);
            allCards.push(card);
          }
        }
      } catch(e) {
        console.error(`地域XML取得失敗: ${href}`, e);
      }
    }
    if(allCards.length === 0){
      container.innerHTML = "<div>全国で発表中の警報・注意報はありません</div>";
      console.log('[warning] loadAllRegions: no active warnings');
      return;
    }
    let index = 0;
    function computeCardsForResolution(containerEl) {
      // 高さベースで表示できる枚数を計算
      const gap = 10; // CSS の gap に合わせる
      const minCardHeight = 58; // styles.css の .card min-height に一致
      const availableHeight = containerEl?.clientHeight || Math.floor(window.innerHeight * 0.4);
      const byHeight = Math.max(1, Math.floor(availableHeight / (minCardHeight + gap)));

      // 横幅（解像度）による上限を決める（小さい画面ほど上限を下げる）
      const vw = window.innerWidth;
      let widthLimit = 7; // デフォルト最大
      if (vw < 480) widthLimit = 2;
      else if (vw < 768) widthLimit = 3;
      else if (vw < 1024) widthLimit = 5;
      else widthLimit = 7;

      // 最終的な候補は高さで計算した枚数と幅上限の最小値
      return Math.max(1, Math.min(byHeight, widthLimit));
    }

      // カードの見た目（高さ・パディング・タイトルサイズ）を解像度に合わせて調整
      function adjustCardSizeForResolution() {
        const vw = window.innerWidth;
        // defaults
        let cardPadding = 14;
        let cardMinHeight = 58;
        let titleSize = 18;
        if (vw < 480) {
          cardPadding = 8;
          cardMinHeight = 44;
          titleSize = 13;
        } else if (vw < 768) {
          cardPadding = 10;
          cardMinHeight = 52;
          titleSize = 14;
        } else if (vw < 1024) {
          cardPadding = 12;
          cardMinHeight = 60;
          titleSize = 16;
        } else {
          cardPadding = 14;
          cardMinHeight = 72;
          titleSize = 18;
        }
        // CSS 変数にセット
        document.documentElement.style.setProperty('--card-padding', cardPadding + 'px');
        document.documentElement.style.setProperty('--card-min-height', cardMinHeight + 'px');
        document.documentElement.style.setProperty('--warning-title-size', titleSize + 'px');
      }

      // 初回とリサイズ時に適用
      window.addEventListener('resize', () => {
        adjustCardSizeForResolution();
        // cards が再計算されるタイミングで表示枚数も変わるのでページをリフレッシュ
        index = 0;
        showNextPage();
      });
      adjustCardSizeForResolution();

    function cardsPerPageCalc() {
      const widget = document.getElementById('warning-widget');
      const dataCount = widget?.getAttribute('data-cards');
      const parsed = dataCount ? parseInt(dataCount, 10) : NaN;
      if (!Number.isNaN(parsed) && parsed > 0) return parsed;
      // WARNINGSIZE が正の整数ならそれを優先（従来互換）
      if (Number.isInteger(WARNINGSIZE) && WARNINGSIZE > 0) return WARNINGSIZE;
      // そうでなければ解像度ベースで算出
      return computeCardsForResolution(container);
    }
    function showNextPage() {
      container.innerHTML = "";
      const cardsPerPage = cardsPerPageCalc();
      const pageCards = allCards.slice(index, index + cardsPerPage);
      pageCards.forEach(c => container.appendChild(c));
      index += cardsPerPage;
      if(index >= allCards.length) index = 0;
    }
    showNextPage();
    console.log('[warning] loadAllRegions: rendered', Math.min(allCards.length, cardsPerPageCalc()), 'cards');
    if (warningShowIntervalId) { clearInterval(warningShowIntervalId); warningShowIntervalId = null; }
    warningShowIntervalId = setInterval(showNextPage, 3000);
    window.addEventListener("resize", () => {
      index = 0;
      showNextPage();
    });
  } catch(e) {
    console.error(e);
    container.innerHTML = "<div>データを取得できませんでした。</div>";
  }
}

// -------------------------
// 上部 NHK ニュース見出し表示
// -------------------------
function ensureTopNewsExists() {
  if (document.getElementById('news-top')) return;
  const el = document.createElement('div');
  el.id = 'news-top';
  el.className = 'news-top';
  el.textContent = 'ニュースを読み込み中...';
  el.style.display = 'none';
  document.body.appendChild(el);
}

async function fetchTopNews() {
  ensureTopNewsExists();
  try {
    const res = await fetch('https://www3.nhk.or.jp/rss/news/cat0.xml');
    const text = await res.text();
    const parser = new DOMParser();
    const xml = parser.parseFromString(text, 'application/xml');
    const items = Array.from(xml.getElementsByTagName('item'));
    const newTitles = items.map(it => it.getElementsByTagName('title')[0]?.textContent?.trim() || '').filter(t => t.length > 0);
    const snapshot = JSON.stringify(newTitles);
    // フィードが変わった場合のみ一巡表示を再スタート
    if (snapshot !== prevTopNewsSnapshot) {
      prevTopNewsSnapshot = snapshot;
      topNewsTitles = newTitles;
      // queue を作成して一巡のみ表示する
      topNewsQueue = topNewsTitles.slice();
      topNewsIndex = 0;
      // ニュース速報を表示してから見出しを順に表示
      const el = document.getElementById('news-top');
      if (el) {
        el.style.display = '';
        el.textContent = '◇ニュース速報◇';
      }
      // 少しだけ速報表示を確保してから各見出しを表示
      setTimeout(() => {
        showNextTopNewsOnce();
      }, TOP_NEWS_ALERT_MS);
    }
    return true;
  } catch (e) {
    console.error('fetchTopNews error', e);
    return false;
  }
}

function updateTopNewsDisplay(text) {
  ensureTopNewsExists();
  const el = document.getElementById('news-top');
  if (!el) return;
  el.textContent = text || '';
}

function showNextTopNewsOnce() {
  stopTopNewsRotation();
  if (!topNewsQueue || topNewsQueue.length === 0) return;
  const next = topNewsQueue.shift();
  updateTopNewsDisplay(next);
  // 次があれば4秒後に再び表示
  if (topNewsQueue.length > 0) {
    topNewsIntervalId = setTimeout(() => {
      showNextTopNewsOnce();
    }, TOP_NEWS_ITEM_MS);
  } else {
    topNewsIntervalId = null;
    // 最後の見出しを表示した後、一定時間で非表示にする
    setTimeout(() => {
      const el = document.getElementById('news-top');
      if (el) el.style.display = 'none';
    }, TOP_NEWS_ITEM_MS);
  }
}

function stopTopNewsRotation() {
  if (topNewsIntervalId) { clearTimeout(topNewsIntervalId); topNewsIntervalId = null; }
}


  </script>
</body>
</html>
