<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>天気図＋テロップ — 統合(all.html)</title>
  <style>
/* inlined styles.css */
html, body {
  margin: 0;
  padding: 0;
  height: 100vh;
  overflow-x: hidden;
  font-family: 'BIZ UDP Gothic', sans-serif;
}

/* ページ全体の背景（地図領域とテロップを含む） */
html, body {
  background-color: #020418;
}

.ticker-wrapper {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 80px; /* テロップを大きく表示するため高さ拡張 */
  background-color: #020418;
  border-top: 1px solid #888888;
  box-sizing: border-box;
  position: relative;
  color: #fff;
  display: flex;
  align-items: center;
  padding-right: 180px; /* 時計のための余白を確保 */
 }

 /* テロップ左側に垂直な目印の棒を表示 */
 .ticker-wrapper::before {
   content: '';
   position: fixed;
   right: 408px; /* 天気図の左隣 */
   bottom: 80px;
   width: 1px;
   height: calc(100vh - 80px);
   background: #888888;
   z-index: 40;
 }
/* テロップ表示用の内部エリア（時計領域と重ならないように幅を制限） */
.ticker-area {
  position: absolute;
  left: 20px; /* 左側に20pxの余白 */
  right: 10px; /* 時計のすぐ左まで拡張 */
  height: 100%;
  overflow: hidden;
}

.ticker-area .ticker {
  position: absolute;
}

.ticker {
  position: absolute;
  white-space: nowrap;
  font-size: 40px; /* フォントを大きく */
  left: 100%;
  top: 50%;
  transform: translateY(-50%);
  line-height: 1;
  will-change: transform;
}

.ticker img {
  vertical-align: middle;
  height: 44px; /* アイコンを大きく */
  margin: 0 8px 0 8px;
}

.clock {
  background-color: #020418;
  font-size: 63px; /* 時計を大きく */
  color: #fff;
  position: absolute;
  top: 46%;
  transform: translateY(-50%); /* 垂直中央に配置してフォントサイズ変更で下に隙間が出ないようにする */
  right: 14px;
  line-height: 1;
  margin: 0;
  padding: 0;
  user-select: none;
}

.temp {
  margin-left: 12px;
  font-weight: bold;
  font-size: 40px; /* 最高/最低気温を大きく */
  user-select: none;
}

.max-temp {
  color: #ff4444; /* 赤 */
}

.min-temp {
  color: #4466ff; /* 青 */
}

.region-name {
  margin-left: 6px;
}

.slash {
  margin: 0;
  color: #fff;
  user-select: none;
  font-weight: normal;
  font-size: 34px; /* 区切り文字も大きめに */
}

/* 天気図表示領域 */
.container {
  width: 100%;
  height: calc(100vh - 80px); /* テロップの高さに合わせて調整 */
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 10px;
  box-sizing: border-box;
}

#loading {
  color: #cccccc;
  text-align: center;
}

#weatherMap {
  /* 右下に固定表示。テロップ（下部）と被らないように配置 */
  position: fixed;
  /* 右端からの余白（十分なスペースを確保） */
  right: 30px;
  bottom: 96px; /* テロップの上に少し余白を確保（テロップ高さ80 + 16） */
  width: min(40vw, 560px);
  max-width: 360px;
  max-height: calc(100vh - 160px);
  object-fit: contain;
  display: block;
  z-index: 50;
  border-radius: 6px;
  box-shadow: 0 6px 18px rgba(0,0,0,0.5);
}

/* 右上に直接表示する警報ページ用フレーム */
/* 埋め込み警報ウィジェット（警報表示を index 内に統合） */
.warning-embedded {
  position: fixed;
  top: 12px;
  right: 12px;
  left: auto;
  z-index: 110;
  /* 幅はビューポートに応じて可変に。白線（right:408px）を越えないよう最大幅を制限 */
  /* widget の right は 12px 固定なので、最大幅 = 408px - 12px = 396px */
  width: min(40vw, 396px);
  max-width: 396px;
  /* 高さは JS で天気図の上端に合わせて調整する。フォールバックは 60vh */
  max-height: 60vh;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.04);
  box-shadow: 0 6px 14px rgba(0,0,0,0.35);
  overflow: auto;
  padding: 12px;
  box-sizing: border-box;
}




.warning-embedded #warning-card-container {
  display: flex;
  flex-direction: column;
  gap: 10px;
  align-items: center;
  color: #fff;
  margin-top: 10px; /* タイトルより少し下にずらす */
}

/* タイトル（警報見出し） */
.warning-embedded .warning-title {
  text-align: center;
  font-size: var(--warning-title-size, 18px); /* 可変に */
  color: #e6e6e6;
  margin-bottom: 14px;
  font-weight: 700;
  letter-spacing: 0.02em;
}

.warning-embedded .card {
  /* 強調された長方形（元の見た目に近いスタイル） */
  background: #111;
  border: 2px solid #fff;
  border-radius: 10px;
  padding: var(--card-padding, 14px); /* 可変パディング */
  min-height: var(--card-min-height, 58px); /* 可変高さ */
  width: 100%;
  box-sizing: border-box;
  display: flex;
  gap: 10px;
  align-items: center;
  box-shadow: 0 4px 12px rgba(0,0,0,0.6);
}

.warning-embedded .region { font-weight: bold; color: #fff; }

.warning-embedded .warning {
  padding: 2px 6px;
  border-radius: 5px;
  color: #000;
  text-align: center;
  white-space: nowrap;
}
.warning-embedded .警報 { background-color: red; }
.warning-embedded .注意報 { background-color: yellow; }
/* 廃止 */
/* .warning-embedded .解除 { background-color: gray; } */

/* スクロールバーを非表示（スクロール自体は可能） */
.warning-embedded {
  -ms-overflow-style: none; /* IE/Edge */
  scrollbar-width: none;    /* Firefox */
}
.warning-embedded::-webkit-scrollbar {
  display: none; /* Chrome, Safari, Opera */
  width: 0;
  height: 0;
}

/* iframe 内を埋めるため、内部の body は warning.html 側で管理してください */

/* サイト全体のスクロールバーを非表示にする（スクロールは維持） */
html, body {
  -ms-overflow-style: none; /* IE/Edge */
  scrollbar-width: none;    /* Firefox */
}
html::-webkit-scrollbar, body::-webkit-scrollbar {
  display: none; /* Chrome, Safari, Opera */
  width: 0;
  height: 0;
}
#map {
  position: fixed;
  left: 0px;
  right: 408px;
  top: 0;
  bottom: 80px;
  z-index: 30;
  background: #1d1d1d;
}
/* 左端パネル（地図の上に重ねる） */
/* 上のタイトル長方形 */
#map-left-panel-title {
  position: absolute;
  top: 15px;
  left: 15px;
  width: 400px;
  height: 65px; /* タイトル枠の高さ */
  background: rgba(0, 0, 0, 0.55); /* 下より濃く */
  color: white;
  font-size: 35px;
  font-weight: bold;
  text-align: center;
  line-height: 60px; /* テキストを中央に */
  z-index: 2000;
  pointer-events: none;
  border-radius: 4px;
}

/* 下の半透明パネル */
#map-left-panel {
  position: absolute;
  top: 90px;   /* タイトル（60px）＋余白30px */
  left: 15px;
  width: 400px;
  bottom: 95px;
  background: rgba(0, 0, 0, 0.35);
  z-index: 1999;
  pointer-events: none;
  border-radius: 4px;
}
#eq-info {
  padding: 20px;
  color: white;
  font-family: "Segoe UI", sans-serif;
  pointer-events: auto;
}

/* 最大震度の小さいアイコン */
.eq-maxscale-icon {
  width: 38px;
  height: 38px;
  vertical-align: middle;
}



/* 最大震度テキスト */
.eq-maxscale {
  text-align: center;
  font-size: 38px;
  font-weight: bold;
  color: white; /* ← 白文字 */
}

/* 時刻 */
.eq-time {
    text-align: center;
font-weight: bold;
  font-size: 30px;
}

/* 震源地 */
.eq-hypo {
  font-weight: bold;
  font-size: 30px;
}

/* 下の通常テキスト */
.eq-item {
  font-weight: bold;
  font-size: 30px;
}
.eq-tsunami-warning {
  font-weight: bold;
  font-size: 30px;
}
.leaflet-fade-anim .leaflet-popup {
    transition: 0s;
}
.leaflet-popup-content-wrapper {
	background-color: rgba(255, 255, 255, 0.85);
    box-shadow: 0px 3px 7px 2px rgba(0, 0, 0, 0.4);
    border-radius: 0!important;
    font-family: "ヒラギノ角ゴ-Pro",'Noto Sans JP';
    font-weight: 500;
    user-select: none;
	margin-bottom: 0;
}
.leaflet-popup-content {
    color: black !important;
    font-size: 1.2rem;
    margin: 10px 8px 8px 8px;
}
.leaflet-popup-tip-container {
    display: none;
}
.btns {
    position: absolute;
    bottom: 10px;
    left: 10px;
    z-index: 10000;
    user-select: none;
}
.setsumei, #quakelist, #reload, #map_ichi, #test, #btn_shindo_ichiran, #autoreload, #display_onoff_point_check, #view_info {
    display: inline-block;
    background: #00000088;
    border: white 2.5px solid;
    border-radius: 5px;
    color: white;
    padding: 5px;
    font-family: "ヒラギノ角ゴ-Pro",'Noto Sans JP';
    font-weight: 500;
    font-size: 0.8rem;
    cursor: pointer;
}
#quakelist {
    width: 25em;
    height: calc(2em + 5px);
}
.shindo-legend {
  padding: 8px 12px;
  background: rgba(0,0,0,0.55);
  color: white;
  font-size: 16px;
  line-height: 1.4;
  border-radius: 6px;
  box-shadow: 0 0 6px rgba(0,0,0,0.4);
}
.shindo-legend .legend-title {
  font-weight: bold;
  margin-bottom: 4px;
  text-align: center;
  font-size: 17px;
}
.shindo-legend .legend-item {
  display: flex;
  align-items: center;
  margin: 3px 0;
}
.shindo-legend img {
  width: 22px;
  height: 22px;
  margin-right: 6px;
}

  </style>
   <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
   <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
   <script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha256-/JqT3SQfawRcv/BIHPThkBvs0OEvtFFmqPF/lYI/Cxo=" crossorigin="anonymous"></script>
</head>
</head>
<body>
  <div id="map-left-panel-title">地震情報</div>
<div id="map-left-panel">
    <div id="eq-info">読み込み中...</div>
</div>
  <div class="container">
    <img id="weatherMap" src="" alt="気象庁天気図" style="display:none;" />
    <p id="loading">天気図を読み込み中...</p>
  </div>
  <div class="btns">
       <select id="quakelist"><option>地震情報の取得中…</option></select>
   </div>
  <!-- 右上に警報ウィジェットを直接埋め込み -->
  <div id="warning-widget" class="warning-embedded" aria-label="警報・注意報ウィジェット">
    <div class="warning-title">発表されている警報/注意報</div>
    <div id="warning-card-container">読み込み中...</div>
  </div>
  
<div id="map"></div>
  <div class="ticker-wrapper">
    <div class="ticker-area">
      <div class="ticker" id="ticker"></div>
    </div>
    <div class="clock" id="clock"></div>
  </div>
      <script src="source/JMAPoints.js"></script>

<script src="index.js"></script>
  <script>
const ticker = document.getElementById("ticker");
const wrapper = document.querySelector(".ticker-wrapper");
const tickerArea = document.querySelector('.ticker-area');
const clock = document.getElementById("clock");

// 設定: JS側で枚数だけ指定したい場合はここを編集してください
// WARNINGSIZE を 0 にすると画面解像度に合わせた自動算出を有効にします
const WARNINGSIZE = 0; // 0 = 自動（解像度ベース）。正の整数を入れると固定枚数になります。
const WARNING_WIDGET_ENABLED = true; // false にするとウィジェットを完全に無効化します

// 時計領域とテロップの余白調整
const CLOCK_LEFT_GAP = 12;
function updateTickerAreaRight() {
  if (!tickerArea || !clock) return;
  const cs = window.getComputedStyle(clock);
  const clockRight = parseInt(cs.right) || 8;
  const clockWidth = clock.offsetWidth || 0;
  const rightPx = clockWidth + clockRight + CLOCK_LEFT_GAP;
  tickerArea.style.right = rightPx + 'px';
}
window.addEventListener('resize', updateTickerAreaRight);
window.addEventListener('load', updateTickerAreaRight);

// 天気図要素
const weatherMapImg = document.getElementById('weatherMap');
const loadingText = document.getElementById('loading');

let weatherHTMLs = [];
let combinedItems = []; // ← 天気のみ
let currentIndex = 0;
let animationId = null;
let warningShowIntervalId = null;
let pendingCombinedItems = null;
// 時計
function updateClock() {
  const now = new Date();
  const hh = String(now.getHours()).padStart(2, "0");
  const mm = String(now.getMinutes()).padStart(2, "0");
  const ss = String(now.getSeconds()).padStart(2, "0");
  if (clock) clock.textContent = `${hh}:${mm}:${ss}`;
}
setInterval(updateClock, 1000);
updateClock();

// 天気図読み込み
async function loadWeatherMap() {
  if (!weatherMapImg || !loadingText) return;
  try {
    const res = await fetch('https://www.jma.go.jp/bosai/weather_map/data/list.json');
    const data = await res.json();
    if (data.near && data.near.now && data.near.now.length > 0) {
      const firstCode = data.near.now[21];
      const imageUrl = `https://www.jma.go.jp/bosai/weather_map/data/png/${firstCode}`;
      weatherMapImg.onload = function() {
        weatherMapImg.style.display = 'block';
        loadingText.style.display = 'none';
        updateWarningWidgetHeight();
        console.log('天気図を読み込みました:', imageUrl);
      };
      weatherMapImg.onerror = function(e) {
        console.error('天気図画像読み込みエラー', e);
        loadingText.textContent = '天気図の読み込みに失敗しました';
        updateWarningWidgetHeight();
      };
      weatherMapImg.src = imageUrl;
    } else {
      loadingText.textContent = '天気図データが見つかりませんでした';
    }
  } catch (e) {
    console.error('天気図取得失敗:', e);
    loadingText.textContent = '天気図の読み込みに失敗しました';
  }
}

// ウィジェット高さを天気図上端ギリギリまで合わせる
function updateWarningWidgetHeight() {
  if (!WARNING_WIDGET_ENABLED) return;
  const widget = document.getElementById('warning-widget');
  const map = document.getElementById('weatherMap');
  if (!widget) return;
  const topOffset = 12;
  const gap = 8;
  if (map && map.style.display !== 'none') {
    const rect = map.getBoundingClientRect();
    let maxH = Math.floor(rect.top - gap - topOffset);
    if (maxH < 80) maxH = 80;
    widget.style.maxHeight = maxH + 'px';
    widget.style.overflow = 'auto';
  } else {
    const maxH = Math.max(120, Math.floor(window.innerHeight - topOffset - 24));
    widget.style.maxHeight = Math.min(maxH, Math.floor(window.innerHeight * 0.8)) + 'px';
    widget.style.overflow = 'auto';
  }
}
window.addEventListener('resize', updateWarningWidgetHeight);
window.addEventListener('load', updateWarningWidgetHeight);

// 天気情報取得
async function fetchWeather() {
  try {
    const res = await fetch("https://weathernews.jp/forecast/xml/all.xml");
    const xmlText = await res.text();
    const parser = new DOMParser();
    const xmlDoc = parser.parseFromString(xmlText, "text/xml");
    const points = Array.from(xmlDoc.getElementsByTagName("point"));

    const uniquePoints = {};
    points.forEach(point => {
      const id = point.getAttribute("id");
      if (!uniquePoints[id]) {
        const name = point.getAttribute("name");
        const weatherRaw = point.getElementsByTagName("weather")[0]?.textContent || "";
        const firstWeatherValue = weatherRaw.split(",")[0];
        const iconUrl = `https://weathernews.jp/s/topics/img/wxicon/${firstWeatherValue}.png`;
        const maxtempRaw = point.getElementsByTagName("maxtemp")[0]?.textContent || "";
        const mintempRaw = point.getElementsByTagName("mintemp")[0]?.textContent || "";
        const maxtemp = maxtempRaw.match(/\d+/)?.[0] || "-";
        const mintemp = mintempRaw.match(/\d+/)?.[0] || "-";
        const html = `\n        <img src="${iconUrl}" alt="weather icon">\n        <span class="region-name">${name}</span>\n        <span class="temp max-temp">${maxtemp}℃</span><span class="slash">  /</span><span class="temp min-temp">${mintemp}℃</span>\n      `;
        uniquePoints[id] = html;
      }
    });
    weatherHTMLs = Object.values(uniquePoints);
  } catch (e) {
    console.error("天気取得失敗:", e);
    weatherHTMLs = [`<span>天気情報を取得できませんでした。</span>`];
  }
}


// 天気HTML連結
function getCombinedWeatherHTML() {
  return weatherHTMLs.join('　');
}
// ビルド専用: 合成アイテム配列を返す（ただちに適用しない）
// 返り値の順序: 天気（必ず先頭）→ ニュース見出し（存在すれば続く）
function buildCombinedItems() {
return [ weatherHTMLs.join('　') ]; // ← ニュースなし、天気だけ
}

// テロップ
const speedWeather = 100;
const speedNews = 100;
function startTicker() {
const ticker = document.getElementById("ticker");
const area = document.querySelector('.ticker-area');
if (!ticker) return;


ticker.innerHTML = combinedItems[currentIndex];
let pos = area.offsetWidth;
ticker.style.left = pos + "px";


function anim() {
pos -= 2;
ticker.style.left = pos + "px";
if (pos + ticker.offsetWidth < 0) {
currentIndex = 0;
ticker.innerHTML = combinedItems[0];
pos = area.offsetWidth;
}
animationId = requestAnimationFrame(anim);
}
anim();
}
// 地震メッセージを即時に先頭で流す（強制表示）
function showQuakeNow() {
  // 即時割り込みは行わず、次の一巡が終わった時点で適用する（現在の表示を邪魔しない）
  const newItems = buildCombinedItems();
  if (animationId) {
    pendingCombinedItems = newItems;
  } else {
    combinedItems = newItems;
    currentIndex = 0;
    startTicker();
  }
}

// 全更新
async function updateAll() {
  await loadWeatherMap();
  await fetchWeather();
  if (WARNING_WIDGET_ENABLED && typeof loadAllRegions === 'function') {
    try { await loadAllRegions(); } catch(e){ console.error('loadAllRegions エラー', e); }
    try { updateWarningWidgetHeight(); } catch(e) { /* ignore */ }
  }
  const newItems = buildCombinedItems();
  if (animationId) {
    // 表示中なら一巡が終わるまで適用を保留する
    pendingCombinedItems = newItems;
  } else {
    // 未表示なら即時適用
    combinedItems = newItems;
    currentIndex = 0;
    startTicker();
  }
  // 上部ニュースも更新
  }
async function updateE(){
  GetQuake();
}
updateAll();
setInterval(updateE, 3000);
setInterval(updateAll, 5 * 60 * 1000);// -------------------------
// 警報ウィジェット: DOM を JS 側で生成（HTML側に直接要素は不要）
// -------------------------
function ensureWarningWidgetExists() {
  if (document.getElementById('warning-widget')) return;
  const widget = document.createElement('div');
  widget.id = 'warning-widget';
  widget.className = 'warning-embedded';
  widget.setAttribute('aria-label', '警報・注意報ウィジェット');
  const title = document.createElement('div');
  title.className = 'warning-title';
  title.textContent = '発表されている気象警報/注意報';
  const container = document.createElement('div');
  container.id = 'warning-card-container';
  container.textContent = '読み込み中...';
  widget.appendChild(title);
  widget.appendChild(container);
  const tickerWrapper = document.querySelector('.ticker-wrapper');
  if (tickerWrapper && tickerWrapper.parentNode) tickerWrapper.parentNode.insertBefore(widget, tickerWrapper);
  else document.body.appendChild(widget);
}

// データ取得と表示
async function loadAllRegions() {
  if (!WARNING_WIDGET_ENABLED) return;
  console.log('[warning] loadAllRegions: start');
  ensureWarningWidgetExists();
  const container = document.getElementById("warning-card-container");
  if (!container) return;
  container.innerHTML = "";
  try {
    const res = await fetch('https://www.data.jma.go.jp/developer/xml/feed/extra.xml');
    const text = await res.text();
    const parser = new DOMParser();
    const xml = parser.parseFromString(text, "application/xml");
    const entries = xml.getElementsByTagNameNS("http://www.w3.org/2005/Atom", "entry");
    console.log('[warning] loadAllRegions: extra.xml entries=', entries.length);
    let allCards = [];
    for (let i = 0; i < entries.length; i++) {
      const linkEl = entries[i].getElementsByTagNameNS("http://www.w3.org/2005/Atom", "link")[0];
      if (!linkEl) continue;
      const href = linkEl.getAttribute("href");
      if (!href) continue;
      try {
        const regionRes = await fetch(href);
        const regionText = await regionRes.text();
        const regionXml = parser.parseFromString(regionText, "application/xml");
        const nsBody = "http://xml.kishou.go.jp/jmaxml1/body/meteorology1/";
        const warnings = regionXml.getElementsByTagNameNS(nsBody, "Warning");
        for (let w = 0; w < warnings.length; w++) {
          const items = warnings[w].getElementsByTagNameNS(nsBody, "Item");
          for (let j = 0; j < items.length; j++) {
            const areaEl = items[j].getElementsByTagNameNS(nsBody, "Area")[0] || items[j].getElementsByTagName("Area")[0];
            const kindEl = items[j].getElementsByTagNameNS(nsBody, "Kind")[0] || items[j].getElementsByTagName("Kind")[0];
            if (!areaEl || !kindEl) continue;
            const regionName = areaEl.getElementsByTagName("Name")[0]?.textContent || "不明地域";
            const warningName = kindEl.getElementsByTagName("Name")[0]?.textContent || "";
            const status = kindEl.getElementsByTagName("Status")[0]?.textContent || "";
            // 解除（解除情報）は表示しない
            if (status && status.includes('解除')) continue;
            if (!warningName || status === "発表警報・注意報はなし") continue;
            const card = document.createElement("div");
            card.className = "card";
            const regionDiv = document.createElement("div");
            regionDiv.className = "region";
            regionDiv.textContent = regionName;
            const warningDiv = document.createElement("div");
            warningDiv.className = "warning";
            if(status.includes("解除")) warningDiv.classList.add("解除");
            else if(warningName.includes("警報")) warningDiv.classList.add("警報");
            else warningDiv.classList.add("注意報");
            warningDiv.textContent = `${warningName} ${status}`.trim();
            card.appendChild(regionDiv);
            card.appendChild(warningDiv);
            allCards.push(card);
          }
        }
      } catch(e) {
        console.error(`地域XML取得失敗: ${href}`, e);
      }
    }
    if(allCards.length === 0){
      container.innerHTML = "<div>全国で発表中の警報・注意報はありません</div>";
      console.log('[warning] loadAllRegions: no active warnings');
      return;
    }
    let index = 0;
    function computeCardsForResolution(containerEl) {
      // 高さベースで表示できる枚数を計算
      const gap = 10; // CSS の gap に合わせる
      const minCardHeight = 58; // styles.css の .card min-height に一致
      const availableHeight = containerEl?.clientHeight || Math.floor(window.innerHeight * 0.4);
      const byHeight = Math.max(1, Math.floor(availableHeight / (minCardHeight + gap)));

      // 横幅（解像度）による上限を決める（小さい画面ほど上限を下げる）
      const vw = window.innerWidth;
      let widthLimit = 7; // デフォルト最大
      if (vw < 480) widthLimit = 2;
      else if (vw < 768) widthLimit = 3;
      else if (vw < 1024) widthLimit = 5;
      else widthLimit = 7;

      // 最終的な候補は高さで計算した枚数と幅上限の最小値
      return Math.max(1, Math.min(byHeight, widthLimit));
    }

      // カードの見た目（高さ・パディング・タイトルサイズ）を解像度に合わせて調整
      function adjustCardSizeForResolution() {
        const vw = window.innerWidth;
        // defaults
        let cardPadding = 14;
        let cardMinHeight = 58;
        let titleSize = 18;
        if (vw < 480) {
          cardPadding = 8;
          cardMinHeight = 44;
          titleSize = 13;
        } else if (vw < 768) {
          cardPadding = 10;
          cardMinHeight = 52;
          titleSize = 14;
        } else if (vw < 1024) {
          cardPadding = 12;
          cardMinHeight = 60;
          titleSize = 16;
        } else {
          cardPadding = 14;
          cardMinHeight = 72;
          titleSize = 18;
        }
        // CSS 変数にセット
        document.documentElement.style.setProperty('--card-padding', cardPadding + 'px');
        document.documentElement.style.setProperty('--card-min-height', cardMinHeight + 'px');
        document.documentElement.style.setProperty('--warning-title-size', titleSize + 'px');
      }

      // 初回とリサイズ時に適用
      window.addEventListener('resize', () => {
        adjustCardSizeForResolution();
        // cards が再計算されるタイミングで表示枚数も変わるのでページをリフレッシュ
        index = 0;
        showNextPage();
      });
      adjustCardSizeForResolution();

    function cardsPerPageCalc() {
      const widget = document.getElementById('warning-widget');
      const dataCount = widget?.getAttribute('data-cards');
      const parsed = dataCount ? parseInt(dataCount, 10) : NaN;
      if (!Number.isNaN(parsed) && parsed > 0) return parsed;
      // WARNINGSIZE が正の整数ならそれを優先（従来互換）
      if (Number.isInteger(WARNINGSIZE) && WARNINGSIZE > 0) return WARNINGSIZE;
      // そうでなければ解像度ベースで算出
      return computeCardsForResolution(container);
    }
    function showNextPage() {
      container.innerHTML = "";
      const cardsPerPage = cardsPerPageCalc();
      const pageCards = allCards.slice(index, index + cardsPerPage);
      pageCards.forEach(c => container.appendChild(c));
      index += cardsPerPage;
      if(index >= allCards.length) index = 0;
    }
    showNextPage();
    console.log('[warning] loadAllRegions: rendered', Math.min(allCards.length, cardsPerPageCalc()), 'cards');
    if (warningShowIntervalId) { clearInterval(warningShowIntervalId); warningShowIntervalId = null; }
    warningShowIntervalId = setInterval(showNextPage, 3000);
    window.addEventListener("resize", () => {
      index = 0;
      showNextPage();
    });
  } catch(e) {
    console.error(e);
    container.innerHTML = "<div>データを取得できませんでした。</div>";
  }
}

// -------------------------
// 上部 NHK ニュース見出し表示
// -------------------------
function ensureTopNewsExists() {
  if (document.getElementById('news-top')) return;
  const el = document.createElement('div');
  el.id = 'news-top';
  el.className = 'news-top';
  el.textContent = 'ニュースを読み込み中...';
  el.style.display = 'none';
  document.body.appendChild(el);
}

async function fetchTopNews() {
  ensureTopNewsExists();
  try {
    const res = await fetch('https://www3.nhk.or.jp/rss/news/cat0.xml');
    const text = await res.text();
    const parser = new DOMParser();
    const xml = parser.parseFromString(text, 'application/xml');
    const items = Array.from(xml.getElementsByTagName('item'));
    const newTitles = items.map(it => it.getElementsByTagName('title')[0]?.textContent?.trim() || '').filter(t => t.length > 0);
    const snapshot = JSON.stringify(newTitles);
    // フィードが変わった場合のみ一巡表示を再スタート
    if (snapshot !== prevTopNewsSnapshot) {
      prevTopNewsSnapshot = snapshot;
      topNewsTitles = newTitles;
      // queue を作成して一巡のみ表示する
      topNewsQueue = topNewsTitles.slice();
      topNewsIndex = 0;
      // ニュース速報を表示してから見出しを順に表示
      const el = document.getElementById('news-top');
      if (el) {
        el.style.display = '';
        el.textContent = '◇ニュース速報◇';
      }
      // 少しだけ速報表示を確保してから各見出しを表示
      setTimeout(() => {
        showNextTopNewsOnce();
      }, TOP_NEWS_ALERT_MS);
    }
    return true;
  } catch (e) {
    console.error('fetchTopNews error', e);
    return false;
  }
}

function updateTopNewsDisplay(text) {
  ensureTopNewsExists();
  const el = document.getElementById('news-top');
  if (!el) return;
  el.textContent = text || '';
}

function showNextTopNewsOnce() {
  stopTopNewsRotation();
  if (!topNewsQueue || topNewsQueue.length === 0) return;
  const next = topNewsQueue.shift();
  updateTopNewsDisplay(next);
  // 次があれば4秒後に再び表示
  if (topNewsQueue.length > 0) {
    topNewsIntervalId = setTimeout(() => {
      showNextTopNewsOnce();
    }, TOP_NEWS_ITEM_MS);
  } else {
    topNewsIntervalId = null;
    // 最後の見出しを表示した後、一定時間で非表示にする
    setTimeout(() => {
      const el = document.getElementById('news-top');
      if (el) el.style.display = 'none';
    }, TOP_NEWS_ITEM_MS);
  }
}

function stopTopNewsRotation() {
  if (topNewsIntervalId) { clearTimeout(topNewsIntervalId); topNewsIntervalId = null; }
}


  </script>
</body>
</html>
